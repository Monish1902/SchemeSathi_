/**
 * # Firestore Security Rules
 *
 * ## Core Philosophy
 * This ruleset enforces a strict user-ownership model. All user-specific data, including profiles, recommendations, application statuses, and notifications, is nested within a user's private document tree. Access is granted only to the authenticated owner of that data. Publicly accessible data, like government schemes, is stored in a separate top-level collection and is read-only for all clients to prevent unauthorized modifications.
 *
 * ## Data Structure
 * - `/users/{userId}`: Each document represents a user's profile and serves as the root for their private data.
 * - `/users/{userId}/{subcollection}`: All personal user data (recommendations, applications, notifications) is organized into subcollections under the user's primary document.
 * - `/governmentSchemes/{schemeId}`: A top-level collection for public government scheme information.
 *
 * ## Key Security Decisions
 * - **No User Enumeration**: Listing documents in the top-level `/users` collection is explicitly disallowed to protect user privacy.
 * - **Owner-Only Access**: A user can only read or write data within their own path (e.g., `/users/{their_uid}/...`).
 * - **Read-Only Public Data**: The `/governmentSchemes` collection is publicly readable by anyone, but all client-side write operations (`create`, `update`, `delete`) are disabled. This data must be managed through a trusted server-side process (e.g., Admin SDK).
 * - **Default Secure**: Any path not explicitly matched is inaccessible.
 *
 * ## Denormalization for Authorization
 * Each document within a user's private subcollections (e.g., `ApplicationStatus`, `Notification`) contains a `userId` field. The rules enforce on `create` that this field matches the authenticated user's ID in the path, establishing an unbreakable ownership link. On `update`, this `userId` field is enforced as immutable.
 *
 * ## Structural Segregation
 * The ruleset leverages structural segregation for security and performance. Private user data is kept entirely separate from public `governmentSchemes` data. This avoids complex rules with conditional checks and ensures that queries for public data do not risk exposing private information.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently signed-in user's UID matches the provided userId.
     * This is the core of the ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks for ownership and ensures the document already exists.
     * Crucial for safe update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates that the `firebaseUid` field in a new UserProfile document
     * matches the document's ID, ensuring relational integrity.
     */
    function hasValidProfileDataOnCreate(userId) {
      return request.resource.data.firebaseUid == userId;
    }

    /**
     * Enforces immutability for the UserProfile's core `firebaseUid` field during updates.
     */
    function hasImmutableProfileDataOnUpdate() {
      return request.resource.data.firebaseUid == resource.data.firebaseUid;
    }

    /**
     * Validates that the `userId` field in a new document within a user's
     * subcollection matches the `userId` from the path.
     */
    function hasValidUserIdOnCreate(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * Enforces that the `userId` field in a document within a user's
     * subcollection cannot be changed after creation.
     */
    function hasImmutableUserIdOnUpdate() {
      return request.resource.data.userId == resource.data.userId;
    }

    // ------------------------------------------------------------------------
    // Collection: users
    // ------------------------------------------------------------------------

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow (create) A new user can create their own profile document if their auth UID matches the document ID.
     * @deny (list) A user cannot list all documents in the `/users` collection to prevent user enumeration.
     * @principle Restricts access to a user's own data tree and prevents discovery of other users.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && hasValidProfileDataOnCreate(userId);
      allow update: if isExistingOwner(userId) && hasImmutableProfileDataOnUpdate();
      allow delete: if isExistingOwner(userId);

      // ----------------------------------------------------------------------
      // Subcollection: schemeRecommendations
      // ----------------------------------------------------------------------

      /**
       * @description Secures a user's private scheme recommendations.
       * @path /users/{userId}/schemeRecommendations/{recommendationId}
       * @allow (create) A user can create a recommendation document within their own subcollection.
       * @deny (get) An authenticated user cannot read recommendations belonging to another user.
       * @principle Enforces document ownership within a user's private subcollection.
       */
      match /schemeRecommendations/{recommendationId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidUserIdOnCreate(userId);
        allow update: if isExistingOwner(userId) && hasImmutableUserIdOnUpdate();
        allow delete: if isExistingOwner(userId);
      }

      // ----------------------------------------------------------------------
      // Subcollection: applicationStatuses
      // ----------------------------------------------------------------------

      /**
       * @description Secures a user's private application status trackers.
       * @path /users/{userId}/applicationStatuses/{applicationStatusId}
       * @allow (list) A user can list all application statuses they own.
       * @deny (update) A user cannot update an application status belonging to another user.
       * @principle Enforces document ownership within a user's private subcollection.
       */
      match /applicationStatuses/{applicationStatusId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidUserIdOnCreate(userId);
        allow update: if isExistingOwner(userId) && hasImmutableUserIdOnUpdate();
        allow delete: if isExistingOwner(userId);
      }

      // ----------------------------------------------------------------------
      // Subcollection: notifications
      // ----------------------------------------------------------------------

      /**
       * @description Secures a user's private notifications.
       * @path /users/{userId}/notifications/{notificationId}
       * @allow (delete) A user can delete a notification they own.
       * @deny (create) A user cannot create a notification for another user.
       * @principle Enforces document ownership within a user's private subcollection.
       */
      match /notifications/{notificationId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidUserIdOnCreate(userId);
        allow update: if isExistingOwner(userId) && hasImmutableUserIdOnUpdate();
        allow delete: if isExistingOwner(userId);
      }
    }

    // ------------------------------------------------------------------------
    // Collection: governmentSchemes
    // ------------------------------------------------------------------------

    /**
     * @description Controls access to the public collection of government schemes.
     * @path /governmentSchemes/{schemeId}
     * @allow (get, list) Any client, authenticated or not, can read scheme information.
     * @deny (create, update, delete) All client-side writes are forbidden to protect data integrity.
     * @principle Provides public read access while centralizing data management to a secure backend.
     */
    match /governmentSchemes/{schemeId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}